- 进程与线程<br/>
 线程：线程是指程序在执行过程中，能够执行程序代码的一个执行单元；<br/>

  进程：操作系统中一个程序的执行周期称为一个进程；<br/>
  
  线程是程序执行的最小单元，一个进程可以拥有多个线程，各个线程之间共享程序的内存空间及一些进程的资源，但是 各个线程拥有自己的栈空间；<br/>
  
  创建销毁一个线程比开启一个新进程耗费的资源要少的多，没有线程就没有进程；
-   多线程<br/>多线程之间共享数据，共享数据使得线程之间的通信比进程之间通信更有效、更方便。
- 如何创建多线程？<br/>
  ==多线程的启动永远都是Thread类的start()方法==<br/>
 1.继承Thread类，然后覆写run()方法，调用start()方法开启线程；<br/>
 2.实现Runnable接口，覆写run()方法，调用Thread类的start()方法开启线程；(避免了第一种方式单继承的缺点)<br/>
 3.实现Callable接口，重写call()方法<br/>
     特点：<br/>
    a.Callable可以在结束后返回一个返回值，而Runnable没有这个功能<br/>
    b.Callable的call()方法可以抛出异常，而Runnable的run()方法不能抛出异常<br/>
    c.运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。
- run()方法与start()方法<br/>
 系统通过调用start()方法来启动一个线程，但是该线程并不在运行状态，而是在就绪状态等待JVM调度，在调度过程中，JVM调用线程的run()方法来完成实际的操作，当run()方法执行结束后，次线程就会终止。<br/>
而如果单纯的直接调用run()方法，那就跟调用了我们类中的普通方法一样，并不会达到多线程的目的。
- 线程的各个方法：<br/>
-   sleep()方法:<br/>该方法会使线程进行休眠，等到预计时间再继续执行该线程，在sleep期间，该线程会==交出cpu==，让cpu执行其他任务，但是该方法==不会释放持有对某个对象的锁==，所以，即使调用sleep()方法，其他线程依然无法访问该对象。<br/>
- yield()方法：线程让步方法，调用此方法时会暂停执行当前的线程，并且去执行其他==优先级相同==的线程，yield()方法会让线程交出cpu，但是==不能控制具体交出cpu的时间==，交出cpu后让cpu去执行其他线程，同样的==不会释放锁==，并且只会让拥有相同优先级的线程去获取cpu时间片的机会。调用yield()方法的线程不会到阻塞状态而是到==就绪状态==，所以很有可能再次争取到cpu的时间片。
- join()方法：如果在主方法中调用这个方法，会使主线程进入休眠状态，等到该线程的run方法执行完主线程才会继续执行。
- wait()方法：wait()方法是Object的方法，wait()方法是将当前线程置于“预执行队列”中，在wait()所在的代码处停止执行，直到接到通知或者被中断。wait()方法==只能在同步块或者同步方法中执行==，否则会抛出异常，wait()方法执行后，当前==线程会释放锁==。
- 线程停止：<br/>
1.使用标记位法；<br/>
2.直接使用stop方法；<br/>
3.使用Thread类的interrupt()方法<br/>
  interrupt()方法不会中断线程，只是会改变线程的中断状态，将中断标记设置为true,根据线程的状态决定是否抛出异常，也就是说会给受阻塞的线程发一个信号，这样受阻线程就会退出阻塞状态。
- 守护线程<br/>
  可以用isDaemon()方法区别用户线程与守护线程，如果返回false就是用户线程，返回true就是守护线程；只有当最后一个非守护线程结束时，守护线程才会随着JVM一同停止工作。
- 同步与死锁：

