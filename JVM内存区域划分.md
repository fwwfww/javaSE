###  **JVM内存区域划分**：
- **程序计数器**：<br通过改变程序计数器的值来选取下一条需要执行的字节码指令；若执行的是java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是本地的native 方法，计数器的值为空，==线程私有==
- **方法区**：<br/>==被所有线程所共享==，用于存储已经被加载的类信息、静态变量、常量等。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError异常
- **虚拟机栈**：<br/>java方法执行的内存模型，每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程；==线程私有==，生命周期与线程相同<br/>两种异常：<br/>StackOverflowError<br/>OutOfMemoryError
- **本地方法栈**:<br/>本地方法栈为虚拟机使用到的native方法服务==线程私有==
- **堆**:<br/>==java堆被所有的线程所共享==，在虚拟机启动的时候就创建，java堆的目的就是存放实例对象，java堆可以处于物理不连续的内存空间，只要逻辑上是连续的即可。<br/>当堆上没有内存完成实例分配并且堆也无法扩展时，就会抛出OutOfMemoryError<br/>java内存堆的OOM异常：<br/>内存泄漏、内存溢出<br/>
    -Xms设置堆的最小值<br/>
    -Xmx设置堆的最大值

### GC:<br/>
- java的内存回收采用的是分代回收算法，将堆内存划分为新生代和老年代，新生代采用==复制算法==，而老年代采用==标记整理算法==，新生代又划分为==Eden区==和==Survivor区==，Survivor区分为==From区==和==To区==，比例为8:1:1，当Eden区满时，会触发一次==Minor GC==,将Eden区存活的对象复制至From区，清除Eden区，当Eden区再次满时，会扫描Eden区和From区，把存活的对象复制至To区，然后清除Eden区和From区，当Eden区再次满时，会对Eden区和To区进行扫描，将存活的对象复制到From区，然后清除Eden和To区，当一个对象被复制到15次以上时，会将该对象移至老年代，老年代采用的是==标记整理算法==，当老年代满时先进行整理(将存活的对象复制到一起)，然后触发==Full GC==清除无用的对象。
- 